/*
  Created on Jan 2017
  Agung Pambudi <agung.pambudi5595@gmail.com>
*/

#ifndef servo_lib_h
#define servo_lib_h

#include <inttypes.h>

//### Say which 16 bit timers can be used and in what order
#if defined(__AVR_ATmega1280__)  || defined(__AVR_ATmega2560__)
#define _useTimer5
#define _useTimer1 
#define _useTimer3
#define _useTimer4 
typedef enum { _timer5, _timer1, _timer3, _timer4, _Nbr_16timers } timer16_Sequence_t ;

#elif defined(__AVR_ATmega32U4__)  
#define _useTimer3
#define _useTimer1 
typedef enum { _timer3, _timer1, _Nbr_16timers } timer16_Sequence_t ;

#elif defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__)
#define _useTimer3
#define _useTimer1
typedef enum { _timer3, _timer1, _Nbr_16timers } timer16_Sequence_t ;

#elif defined(__AVR_ATmega128__) ||defined(__AVR_ATmega1281__)||defined(__AVR_ATmega2561__)
#define _useTimer3
#define _useTimer1
typedef enum { _timer3, _timer1, _Nbr_16timers } timer16_Sequence_t ;

#else  //### everything else
#define _useTimer1
typedef enum { _timer1, _Nbr_16timers } timer16_Sequence_t ;                  
#endif

#define ServoLib_VERSION           2  //### software version of this library
#define MIN_PULSE_WIDTH       544     //### the shortest pulse sent to a servo  
#define MAX_PULSE_WIDTH      2400     //### the longest pulse sent to a servo 
#define DEFAULT_PULSE_WIDTH  1500     //### default pulse width when servo is attached
#define REFRESH_INTERVAL    20000     //### minumim time to refresh servos in microseconds 
#define SERVOS_PER_TIMER       12     //### the maximum number of servos controlled by one timer 
#define MAX_SERVOS   (_Nbr_16timers  * SERVOS_PER_TIMER)
#define INVALID_SERVO         255     //### flag indicating an invalid servo index
#define CURRENT_SEQUENCE_STOP   255   //### used to indicate the current sequence is not used and sequence should stop

typedef struct  {
  uint8_t nbr        :6 ;             //### a pin number from 0 to 63
  uint8_t isActive   :1 ;             //### true if this channel is enabled, pin not pulsed if false 
} ServoPin_t   ;  

typedef struct {
  ServoPin_t Pin;
  unsigned int ticks;
	unsigned int value;
	unsigned int target;
	uint8_t speed;
} servo_t;                            //### Extension for slowmove

typedef struct {
  uint8_t position;
  uint8_t speed;
} servoSequencePoint;

class ServoLib{
public:
  ServoLib();
  uint8_t attach(int pin);                    //### attach the given pin to the next free channel, sets pinMode, returns channel number or 0 if failure
  uint8_t attach(int pin, int min, int max);  //### as above but also sets min and max values for writes. 
  void detach();
  void write(int value);                      //### if value is < 200 its treated as an angle, otherwise as pulse width in microseconds
  void write(int value, uint8_t speed);       //### Move to given position at reduced speed, speed=0 is identical to write, speed=1 slowest and speed=255 fastest.
  void write(int value, uint8_t speed, bool wait); //### wait parameter causes call to block until move completes
  void writeMicroseconds(int value);          //### Write pulse width in microseconds 
  void slowmove(int value, uint8_t speed);
  void stop();                                //### stop the servo where it is  
  int read();                                 //### returns current pulse width as an angle between 0 and 180 degrees
  int readMicroseconds();                     //### returns current pulse width in microseconds for this servo (was read_us() in first release)
  bool attached();                            //### return true if this servo is attached, otherwise false 
  uint8_t sequencePlay(servoSequencePoint sequenceIn[], uint8_t numPositions, bool loop, uint8_t startPos);
  uint8_t sequencePlay(servoSequencePoint sequenceIn[], uint8_t numPositions); //### play a looping sequence starting at position 0
  void sequenceStop();                        //### stop movement
  void wait();                                //### wait for movement to finish  
  bool isMoving();                            //### return true if servo is still moving
private:
   uint8_t servoIndex;                        //### index into the channel data for this servo
   int8_t min;                                //### minimum is this value times 4 added to MIN_PULSE_WIDTH    
   int8_t max;                                //### maximum is this value times 4 added to MAX_PULSE_WIDTH
   servoSequencePoint * curSequence;          //### for sequences
   uint8_t curSeqPosition;                    //### for sequences
};
#endif
